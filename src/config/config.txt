#include "config/config.hpp"
#include "config/configKeys.hpp"
#include "core.hpp"
#include <cstring>
#include <filesystem>
#include <fmt/core.h>
#include <lua.hpp>
#include <vector>

namespace config {

static std::filesystem::file_time_type lastModified;
static Editor editor;

std::optional<std::filesystem::path> findConfigFile() {
    std::vector<std::filesystem::path> candidates;
    candidates.push_back("/Users/juderozario/Projects/texteditor/src/config.lua");
    candidates.push_back("/home/juderozario/Projects/texteditor/src/config.lua");
    if (const char *home = std::getenv("HOME")) {
        candidates.push_back(std::filesystem::path(home) / ".editor.lua");
        candidates.push_back(std::filesystem::path(home) / ".config" / "editor" / "editor.lua");
    }
    for (const auto &path : candidates) {
        if (std::filesystem::exists(path)) {
            return path;
        }
    }
    return std::nullopt;
}

void load(const char *path) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    if (luaL_loadfile(L, path) || lua_pcall(L, 0, 1, 0) != 0) {
        core::logError(fmt::format("Lua error: {}", lua_tostring(L, -1)).c_str());
        lua_close(L);
        return;
    }

    if (!lua_istable(L, -1)) {
        SDL_Log("Lua config did not return a table");
        lua_close(L);
        return;
    }

    getUIConfig(L);
    getPreferenceConfig(L);
    getThemeConfig(L);
    getFontConfig(L);
    getInputConfig(L);
    getPluginsConfig(L);
    getFileConfig(L);

    lua_pop(L, 1); // Pop config table
    lua_close(L);
    lastModified = std::filesystem::last_write_time(path);
}

Color getBackgroundColor() { return editor.colors.background; }

bool configChanged(const char *path) {
    auto current = std::filesystem::last_write_time(path);
    return current != lastModified;
}

ColorRGB parseHexToString(const char *color) {
    std::string clean = color;

    if (!clean.empty() && clean[0] == '#') {
        clean = clean.substr(1);
    }

    if (clean.length() != 6) {
        return ColorRGB{.r = 255, .g = 255, .b = 255};
    }

    ColorRGB c;
    c.r = std::stoi(clean.substr(0, 2), nullptr, 16);
    c.g = std::stoi(clean.substr(2, 2), nullptr, 16);
    c.b = std::stoi(clean.substr(4, 2), nullptr, 16);
    return c;
}

void getConfigColorValue(lua_State *L, const char *key, Color *value) {
    lua_getfield(L, -1, key);
    if (lua_istable(L, -1)) {
        const char *color_rgb;
        unsigned int alpha;
        getConfigValue(L, configKeys::color::RGB, &color_rgb);
        getConfigValue(L, configKeys::color::Alpha, &alpha);
        value->color = parseHexToString(color_rgb);
        value->alpha = alpha;
    } else {
        value->color = ColorRGB{.r = 0, .g = 0, .b = 0};
        value->alpha = 255;
    }
    lua_pop(L, 1);
}

void getUIConfig(lua_State *L) {
    lua_getfield(L, -1, configKeys::editor::UI);
    if (lua_istable(L, -1)) {
        getConfigValue(L, configKeys::ui::Theme, &editor.ui.theme);

        const char *cursor_style;
        const char *line_numbers;

        getConfigValue(L, configKeys::ui::CursorStyle, &cursor_style);
        if (strcmp(cursor_style, "block") == 0) {
            editor.ui.cursor_style = CursorStyleOpts::Block;
        } else if (strcmp(cursor_style, "line") == 0) {
            editor.ui.cursor_style = CursorStyleOpts::Line;
        } else if (strcmp(cursor_style, "underline") == 0) {
            editor.ui.cursor_style = CursorStyleOpts::Underline;
        }

        getConfigValue(L, configKeys::ui::LineNumbers, &line_numbers);
        if (strcmp(line_numbers, "absolute") == 0) {
            editor.ui.line_numbers = LineNumbersOpts::Absolute;
        } else if (strcmp(line_numbers, "relative") == 0) {
            editor.ui.line_numbers = LineNumbersOpts::Relative;
        } else if (strcmp(line_numbers, "hidden") == 0) {
            editor.ui.line_numbers = LineNumbersOpts::Hidden;
        }

        getConfigValue(L, configKeys::ui::StatusBarVisible, &editor.ui.status_bar_visible);
        getConfigValue(L, configKeys::ui::TabBarVisible, &editor.ui.tab_bar_visible);
        getConfigValue(L, configKeys::ui::HighlightCurrentLine, &editor.ui.highlight_current_line);
        getConfigValue(L, configKeys::ui::ShowWhitespace, &editor.ui.show_whitespace);
        getConfigValue(L, configKeys::ui::ShowIndentGuides, &editor.ui.show_indent_guides);
        getConfigValue(L, configKeys::ui::ScalePercent, &editor.ui.ui_scale_percent);
    }
    lua_pop(L, 1);
}

void getInputConfig(lua_State *L) {
    lua_getfield(L, -1, configKeys::editor::Input);
    if (lua_istable(L, -1)) {
        getConfigValue(L, configKeys::input::ShortcutSave, &editor.input.shortcut_save);
        getConfigValue(L, configKeys::input::ShortcutSearch, &editor.input.shortcut_search);
        getConfigValue(L, configKeys::input::ShortcutSplitHorizontal, &editor.input.shortcut_split_horizontal);
        getConfigValue(L, configKeys::input::ShortcutSplitVertical, &editor.input.shortcut_split_vertical);
        getConfigValue(L, configKeys::input::VimMode, &editor.input.vim_mode);
        getConfigValue(L, configKeys::input::Autocomplete, &editor.input.autocomplete);
        getConfigValue(L, configKeys::input::ClipboardIntegration, &editor.input.clipboard_integration);
        getConfigValue(L, configKeys::input::KeyRepeatDelayMS, &editor.input.key_repeat_delay_ms);
        getConfigValue(L, configKeys::input::KeyRepeatRateMS, &editor.input.key_repeat_rate_ms);
        getConfigValue(L, configKeys::input::MouseSelection, &editor.input.mouse_selection);
        getConfigValue(L, configKeys::input::DragAndDrop, &editor.input.drag_and_drop);
    }
    lua_pop(L, 1);
}

void getThemeConfig(lua_State *L) {
    lua_getfield(L, -1, configKeys::editor::Theme); // Push theme config
    if (lua_istable(L, -1)) {
        struct ColorBinding {
            const char *key;
            Color *target;
        };

        static const std::vector<ColorBinding> bindings = {
            {configKeys::theme::Background, &editor.colors.background},
            {configKeys::theme::Foreground, &editor.colors.foreground},
            {configKeys::theme::Cursor, &editor.colors.cursor},
            {configKeys::theme::Selection, &editor.colors.selection},
            {configKeys::theme::LineHighlight, &editor.colors.line_highlight},
            {configKeys::theme::LineNumber, &editor.colors.line_number},
            {configKeys::theme::Gutter, &editor.colors.gutter},
            {configKeys::theme::Whitespace, &editor.colors.whitespace},
            {configKeys::theme::Keyword, &editor.colors.keyword},
            {configKeys::theme::String, &editor.colors.string},
            {configKeys::theme::Comment, &editor.colors.comment},
            {configKeys::theme::Function, &editor.colors.function},
            {configKeys::theme::Type, &editor.colors.type},
            {configKeys::theme::Operator, &editor.colors.operator_},
            {configKeys::theme::Constant, &editor.colors.constant},
            {configKeys::theme::Error, &editor.colors.error},
            {configKeys::theme::Warning, &editor.colors.warning},
            {configKeys::theme::Info, &editor.colors.info},
            {configKeys::theme::DiffAdd, &editor.colors.diff_add},
            {configKeys::theme::DiffChange, &editor.colors.diff_change},
            {configKeys::theme::DiffRemove, &editor.colors.diff_remove},
            {configKeys::theme::DiagnosticError, &editor.colors.diagnostic_error},
            {configKeys::theme::DiagnosticInfo, &editor.colors.diagnostic_info},
            {configKeys::theme::DiagnosticWarning, &editor.colors.diagnostic_warning},
            {configKeys::theme::PopupBackground, &editor.colors.popup_background},
            {configKeys::theme::TooltipBorder, &editor.colors.tooltip_border},
            {configKeys::theme::CompletionBackground, &editor.colors.completion_background},
            {configKeys::theme::InactiveWindowBackground, &editor.colors.inactive_window_background},
            {configKeys::theme::ActiveTabBackground, &editor.colors.active_tab_background},
            {configKeys::theme::HoverTabBackground, &editor.colors.hover_tab_background}};

        for (const auto &binding : bindings) {
            getConfigColorValue(L, binding.key, binding.target);
        }
    }
    lua_pop(L, 1); // Pop theme config
}

void getFontConfig(lua_State *L) {
    lua_getfield(L, -1, configKeys::editor::Font);
    if (lua_istable(L, -1)) {
        getConfigValue(L, configKeys::font::Size, &editor.font.size);
        getConfigValue(L, configKeys::font::LineHeight, &editor.font.line_height);
        getConfigValue(L, configKeys::font::Ligatures, &editor.font.ligatures);
        getConfigColorValue(L, configKeys::font::Color, &editor.font.color);

        lua_getfield(L, -1, configKeys::font::Family);
        if (lua_istable(L, -1)) {
            int len = lua_rawlen(L, -1);
            for (int i = 1; i <= len; i++) {
                lua_geti(L, -1, i);
                if (lua_isstring(L, -1)) {
                    editor.font.family.push_back(lua_tostring(L, -1));
                }
                lua_pop(L, 1);
            }
        }
        lua_pop(L, 1);
    }
    lua_pop(L, 1);
}

void getPreferenceConfig(lua_State *L) {
    lua_getfield(L, -1, configKeys::editor::Preference);
    if (lua_istable(L, 1)) {
        getConfigValue(L, configKeys::preference::TabWidth, &editor.preference.tab_width);

        const char *auto_format;
        getConfigValue(L, configKeys::preference::AutoFormat, &auto_format);
        if (strcmp(auto_format, "on_save")) {
            editor.preference.auto_format = AutoFormatOpts::OnSave;
        } else if (strcmp(auto_format, "on_paste")) {
            editor.preference.auto_format = AutoFormatOpts::OnPaste;
        }

        getConfigValue(L, configKeys::preference::AutoFormat, &editor.preference.auto_format);
        getConfigValue(L, configKeys::preference::BracketMatching, &editor.preference.bracket_matching);
        getConfigValue(L, configKeys::preference::AutoCloseBrackets, &editor.preference.auto_close_brackets);
        getConfigValue(L, configKeys::preference::WordWrap, &editor.preference.word_wrap);
        getConfigValue(L, configKeys::preference::TrimTrailingWhitespaceOnSave,
                       &editor.preference.trim_trailing_whitespace_on_save);
        getConfigValue(L, configKeys::preference::InsertFinalNewlineOnSave, &editor.preference.insert_final_newline_on_save);
        getConfigValue(L, configKeys::preference::HighlightActiveScope, &editor.preference.highlight_active_scope);
        getConfigValue(L, configKeys::preference::AutoIndent, &editor.preference.auto_indent);
    }
    lua_pop(L, 1);
}

void getPluginsConfig(lua_State *L) {
    lua_getfield(L, -1, configKeys::editor::Plugins);
    if (lua_istable(L, -1)) {
        getConfigValue(L, configKeys::plugins::Lsp, &editor.plugins.lsp);
        getConfigValue(L, configKeys::plugins::Snippets, &editor.plugins.snippets);
        getConfigValue(L, configKeys::plugins::Git, &editor.plugins.git);
        getConfigValue(L, configKeys::plugins::Linter, &editor.plugins.linter);
        // getConfigValue(L, configKeys::plugins::Debugger, &editor.plugins.lsp);
        getConfigValue(L, configKeys::plugins::FileExplorer, &editor.plugins.file_explorer);
        // getConfigValue(L, configKeys::plugins::BuildTasks, &editor.plugins.lsp);
        getConfigValue(L, configKeys::plugins::HotReload, &editor.plugins.hot_reload);
        // getConfigValue(L, configKeys::plugins::Sandboxing, &editor.plugins.lsp);
    }
    lua_pop(L, 1);
}

void getFileConfig(lua_State *L) {
    lua_getfield(L, -1, configKeys::editor::File);
    if (lua_istable(L, -1)) {
        const char *autosave_mode;
        getConfigValue(L, configKeys::file::AutosaveMode, &autosave_mode);
        if (strcmp(autosave_mode, "on_focus") == 0) {
            editor.file.autosave_mode = AutosaveModeOpts::OnFocus;
        } else if (strcmp(autosave_mode, "manual") == 0) {
            editor.file.autosave_mode = AutosaveModeOpts::Manual;
        } else if (strcmp(autosave_mode, "delay") == 0) {
            editor.file.autosave_mode = AutosaveModeOpts::Delay;
        }
        getConfigValue(L, configKeys::file::Delay, &editor.file.delay);

        lua_getfield(L, -1, configKeys::file::ExcludePatterns);
        if (lua_istable(L, -1)) {
            int len = lua_rawlen(L, -1);
            for (int i = 1; i <= len; i++) {
                lua_geti(L, -1, i);
                if (lua_isstring(L, -1)) {
                    editor.file.exclude_patterns.push_back(lua_tostring(L, -1));
                }
                lua_pop(L, 1);
            }
        }

        getConfigValue(L, configKeys::file::ShowHiddenFiles, &editor.file.show_hidden_files);
        getConfigValue(L, configKeys::file::FileWatcher, &editor.file.file_watcher);
    }
    lua_pop(L, 1);
}
}
